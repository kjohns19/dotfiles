#!/usr/bin/env python3

import argparse
import re
import os
import errno

def main():
    args = parse_args()

    for cls in args.classes:
        classname, namespaces = parse_class(cls, args.namespaces)
        make_class(classname, namespaces, args.mkdirs)


def parse_args():
    desc = 'Create a header and implementation file for a class or classes'
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument(
        '-n', '--namespaces', action='store',
        help='Put all classes within these namespaces (e.g. foo::bar)')
    parser.add_argument(
        '-d', '--mkdirs', action='store_true',
        help='Make directories for namespaces (e.g. foo/bar/)')
    parser.add_argument(
        'classes', action='store', nargs='*',
        help='Classes to make. May contain namespaces')
    return parser.parse_args()


def parse_class(cls, all_namespaces):
    namespaces = all_namespaces.split('::') if all_namespaces else []
    cls_split = cls.split('::')
    classname = cls_split[-1]
    namespaces += cls_split[0:-1]
    return classname, namespaces

def make_class(classname, namespaces, mkdirs):
    namespace_snake = '_'.join([ns.upper() for ns in namespaces])
    if namespaces:
        namespace_snake += '_'
    snake_name = '_'.join([s.upper() for s in re.findall(r'[A-Z][^A-Z]*', classname)])
    snake_lower = snake_name.lower()

    guard = 'INCLUDED_{}{}_HPP'.format(namespace_snake, snake_name)

    headerfile = '{}.hpp'.format(snake_lower)
    classfile = '{}.cpp'.format(snake_lower)

    if mkdirs and namespaces:
        path = os.path.join(*namespaces)
        os.makedirs(path, exist_ok=True)
        headerfile = os.path.join(path, headerfile)
        classfile = os.path.join(path, classfile)

    write_header(headerfile, guard, namespaces, classname)
    write_class(classfile, headerfile, namespaces, classname)

class NoFile:
    def __bool__():
        return False
    def __enter__(self):
        pass
    def __exit__(self, type, value, tb):
        pass

def openNew(filename):
    try:
        flags = os.O_CREAT | os.O_EXCL | os.O_WRONLY
        fh = os.open(filename, flags, mode=0o644)
    except OSError as e:
        if e.errno == errno.EEXIST:
            print('{} already exists'.format(filename))
            return NoFile()
        else:
            raise
    else:
        return os.fdopen(fh, 'w')

def write_header(filename, guard, ns, cls):
    data = '\n'.join([
        '#ifndef {}',
        '#define {}',
        '{}',
        '{}',
        '{}',
        '#endif // {}'
    ]).format(guard, guard, ns_header(ns), class_def(cls), ns_footer(ns), guard)

    with openNew(filename) as outfile:
        if outfile:
            print(data, file=outfile)


def write_class(filename, header, namespaces, classname):
    data = '\n'.join([
        '#include <{}>',
        '{}',
        '// TODO',
        '{}'
    ]).format(header, ns_header(namespaces), ns_footer(namespaces))

    with openNew(filename) as outfile:
        if outfile:
            print(data, file=outfile)


def ns_header(namespaces):
    header = '\n' if namespaces else ''
    header += '\n'.join(['namespace ' + ns + ' {' for ns in namespaces])
    if namespaces:
        header += '\n'
    return header


def ns_footer(namespaces):
    footer = '\n' if namespaces else ''
    footer += '\n'.join(['} // close namespace ' + ns for ns in reversed(namespaces)])
    if namespaces:
        footer += '\n'
    return footer


def class_def(classname):
    return '\n'.join([
        'class {}',
        '{}',
        'public:',
        '    // TODO',
        'private:',
        '    // TODO',
        '{};'
    ]).format(classname, '{', '}')


if __name__ == '__main__':
    main()
